# .github/workflows/deployment.yml
name: CI/CD Pipeline to VKE

on:
  push:
    branches:
      - main
    paths:
      - "server/**"
      - ".github/workflows/deployment.yml"
  pull_request:
    branches:
      - main
    paths:
      - "server/**"
      - ".github/workflows/deployment.yml"

env:
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
  DOCKER_REGISTRY: docker.io
  KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}

jobs:
  build-and-test:
    name: Build and Test Services
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: "17"
          distribution: "temurin"
          cache: "maven"

      - name: Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Cache Maven dependencies
        uses: actions/cache@v4
        with:
          path: ~/.m2
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      - name: Install Parent POM
        run: mvn clean install -N -q
        working-directory: server

      - name: Build Common Module
        run: mvn clean install -q -DskipTests
        working-directory: server/common

      - name: Test Common Module
        run: mvn test
        working-directory: server/common

      - name: Build API Gateway Service
        run: mvn compile -q
        working-directory: server/api-gateway-service

      - name: Test API Gateway Service
        run: mvn test
        working-directory: server/api-gateway-service

      - name: Build Authentication Service
        run: mvn compile -q
        working-directory: server/authentication-service

      - name: Test Authentication Service
        run: mvn test
        working-directory: server/authentication-service

      - name: Build Map Storage Service
        run: mvn compile -q
        working-directory: server/map-storage-service

      - name: Test Map Storage Service
        run: mvn test
        working-directory: server/map-storage-service

      - name: Build Logger Service
        run: mvn compile -q
        working-directory: server/logger-service

      - name: Test Logger Service
        run: mvn test
        working-directory: server/logger-service

      - name: Install Python Dependencies for Solver Service
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements_test.txt
        working-directory: server/solver-service

      - name: Test Python Solver Service
        run: |
          python -m pytest tests/ -v --tb=short
        working-directory: server/solver-service

  build-and-push-docker:
    name: Build and Push Docker Images
    needs: build-and-test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ env.DOCKER_PASSWORD }}

      - name: Build and Push Docker Images
        run: |
          BUILD_TAG=${{ github.run_number }}
          DOCKER_ORG=${{ env.DOCKER_USERNAME }}

          # Define your services and their image names
          declare -A services=(
              ["api-gateway-service"]="spring-api-gateway-service"
              ["authentication-service"]="spring-authentication-service"
              ["map-storage-service"]="spring-map-storage-service"
              ["logger-service"]="spring-logger-service"
              ["solver-service"]="flask-solver-service"
          )

          for service_dir in "${!services[@]}"; do
              image_name="${services[$service_dir]}"
              echo "Building and pushing ${image_name}..."
              # Use correct build context - server directory with service-specific Dockerfile
              docker build --platform linux/amd64 -t "${DOCKER_ORG}/${image_name}:${BUILD_TAG}" \
                           -f "${service_dir}/Dockerfile" .
              docker push "${DOCKER_ORG}/${image_name}:${BUILD_TAG}"
              
              docker tag "${DOCKER_ORG}/${image_name}:${BUILD_TAG}" "${DOCKER_ORG}/${image_name}:latest"
              docker push "${DOCKER_ORG}/${image_name}:latest"
          done
        working-directory: server

  deploy:
    name: Deploy to Kubernetes
    needs: build-and-push-docker
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: "v1.28.2"

      - name: Configure Kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ env.KUBE_CONFIG }}" > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Update Deployment with new image tags
        run: |
          BUILD_TAG=${{ github.run_number }}
          DOCKER_ORG=${{ env.DOCKER_USERNAME }}

          # Updated deployment names and container names to match your K8s manifests
          declare -A services=(
              ["api-gateway-service"]="spring-api-gateway-service"
              ["authentication-service"]="spring-authentication-service"
              ["map-storage-service"]="spring-map-storage-service"
              ["logger-service"]="spring-logger-service"
              ["solver-service"]="flask-solver-service"
          )

          for deployment_name in "${!services[@]}"; do
              image_name="${services[$deployment_name]}"
              container_name="${deployment_name}"  # Container names match deployment names
              echo "Updating deployment '${deployment_name}' with image '${DOCKER_ORG}/${image_name}:${BUILD_TAG}'"
              
              kubectl set image deployment/${deployment_name} \
                          ${container_name}="${DOCKER_ORG}/${image_name}:${BUILD_TAG}" \
                          -n fourcolour \
                          --record
              
              kubectl rollout status deployment/${deployment_name} -n fourcolour --timeout=5m
          done
        working-directory: server/k8s

      - name: Apply infrastructure manifests
        run: |
          # Apply specific manifests in order, excluding setup scripts and templates
          echo "Applying infrastructure manifests..."
          kubectl apply -f namespace.yaml
          kubectl apply -f configmap.yaml
          kubectl apply -f service.yaml
          kubectl apply -f postgres.yaml
          kubectl apply -f mongo.yaml
          kubectl apply -f redis.yaml
          kubectl apply -f kafka.yaml

          # Apply application service manifests
          kubectl apply -f api-gateway-service.yaml
          kubectl apply -f authentication-service.yaml
          kubectl apply -f map-storage-service.yaml
          kubectl apply -f logger-service.yaml
          kubectl apply -f solver-service.yaml

          echo "Infrastructure deployment complete!"
        working-directory: server/k8s

      - name: Run health check on the API Gateway
        run: |
          max_retries=10
          retry_interval=10

          for i in $(seq 1 $max_retries); do
              echo "Attempt $i/$max_retries: Checking API Gateway health..."
              
              # Try HTTPS endpoint first (preferred)
              if curl -f -k "https://api.149.248.46.187.nip.io/actuator/health"; then
                  echo "HTTPS health check successful!"
                  exit 0
              fi
              
              # Fallback to HTTP if HTTPS not ready yet
              ingress_ip=$(kubectl get ingress fourcolour-ingress-ip -n fourcolour -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "149.248.46.187")
              if [ -n "$ingress_ip" ]; then
                  if curl -f "http://$ingress_ip/actuator/health"; then
                      echo "HTTP health check successful (fallback)!"
                      exit 0
                  fi
              fi
              
              echo "Health check failed. Retrying in $retry_interval seconds..."
              sleep $retry_interval
          done
          echo "Health check failed after multiple retries."
          exit 1
        working-directory: server/k8s
